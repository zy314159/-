**指令集**：一台计算机所能执行的指令的集合

# 指令格式设计
## 指令中的地址码
一条指令必须包含显式或隐式地包含：
1. 操作码。操作码指定指令的操作类型
2. 源操作数或其地址（即与源操作数有关的相关信息）。指出源操作数或其所在的地址，可以是主（虚）存、寄存器编号或者I/O端口，也可直接给出立即数
3. 结果的地址。结果所存放的地址，可以是主（虚）存、寄存器编号或者I/O端口
4. 下条指令地址

根据指令*显式*给出的地址个数，可分为三地址指令、二地址指令、单地址指令和零地址指令。

## 如何设计好的指令

好的指令的特征：总体短、操作码长、无二义、长度为字节的整数倍、合理的地址段个数、规整。

# 指令系统设计
**设计指令系统的基本原则**：
1. 完备性。指令的操作类型应当足以编制任何可计算程序，但不能太复杂，否则会增加硬件实现的难度
2. 兼容性。高档机的指令应当兼容低端机的指令。
3. 均匀性。运算指令应能处理多种数据类型数据。
4. 可扩充性。操作码字段要留出一定的编码空间，以便以后扩充指令集。

## 基本设计问题（<font face='Consolas'>Trade-Off</font>）
1. 操作码的个数、种类、复杂度？
	- <font face='Consolas'>Turing Complete</font>：必须满足load指令、store指令、INC指令和BRN指令
	- 操作码复杂度太低会导致程序编制困难，但操作码复杂度太高则会占用太多指令位数，导致占用内存变大。
2. 需要对哪几种数据进行操作？
3. 指令格式？规整型（定长操作码和定长指令字） or 紧凑型（变长操作码和变长指令字）？
	- 规整型指令为了满足指令格式的统一必然会存在一些冗余位数，增大空间开销，但规整型指令使得指令译码变得简单，减少了时间开销。
4. 通用寄存器的个数、功能和长度？
	- 通用寄存器太少，程序访存次数就会变多；通用寄存器太多，存取寄存器的时间就会变长。
	- 是否需要栈指针寄存器（指示函数调用栈的栈顶）？栈帧寄存器？
	- Intel的IA-32：寄存器拓展方式——8位、16位、32位等多种操作数长度寄存器
	- MIPS：固定寄存器宽度
5. 寻址方式。
	- MIPS：先通过操作码确定指令类型，从而确定每个操作数的寻址方式
	- IA-32：有专门的寻址方式字段。
6. 下条指令从哪来？一般：PC + 本条指令长度

## 操作数类型
1. 指针或者地址：无符号整数
2. 数值数据：带符号整数（二进制补码）和浮点数（IEEE-754），十进制数（可选，NBCD码（8421码））
3. 位（串）、字符（串） 

## 寻址方式
1. 立即寻址：在指令中直接给出操作数。
2. 直接寻址：在指令中给出操作数的有效地址。
3. 间接寻址：在指令中给出的地址码是指向操作数的指针。
4. 寄存器寻址：在指令中给出存储操作数的寄存器编号。
5. 寄存器间接寻址：在指令中给出存储指向操作数指针的寄存器编码。
6. 变址寻址（程序运行时寻址，如线性表的寻址）：指令给出基址$A$，加上变址寄存器$I$的内容（相当于数组下标），形成地址。
	- 前变址：$EA = (I+(A))$
	- 后变址：$EA=(I)+(A)$
7. 相对寻址：指令给出相对于PC的偏移量。
8. 基址寻址：指令给出相对于基址寄存器内存储的地址的偏移量。
9. 其他寻址方式：如栈操作指令。

## 操作类型
1. 算术和逻辑运算指令
2. 移位指令
3. 传送指令
4. 串指令
5. 顺序控制指令
6. CPU控制指令（操作系统内核代码调用）
7. 输入输出指令

## 操作码编码
希望降低空间开销：紧凑的变长操作码和变长指令字
希望降低时间开销：定长操作码和定长指令字
### 定长操作码
如:<font face='Consolas'>IBM360/370</font>

### 扩展操作码
等长扩展、不等长扩展

## 条件测试方式
标志位存放在程序状态字寄存器(PSW)中

**带符号数和无符号数生成标志位的运算是否不同**？
*相同，因为计算机并不知道自己处理的是带符号数还是无符号数*

如何判断$A \gt B$?
带符号整数：$ZF=0 \cap SF \equiv OF$
无符号整数：$ZF=0\cap CF = 0$

## 指令设计风格
1. 按操作数位置指定风格：累加器型、栈型、通用寄存器型、Load\Store型
2. 按指令格式复杂程度：CISC、RISC
## 异常和中断处理机制

中断：由I/O设备触发的，与当前正在执行的指令无关的异步事件。又称为外中断。
异常：处理器在执行一条指令时，由处理器在其内部检测到的与正在执行的指令相关的同步事件。分为故障、陷入、和终止。又称为内中断。

# 实例：<font face='Consolas'>MIPS</font>指令集
1. **寄存器ll**：32个32位通用寄存器，寄存器编号占5位，汇编表示以$开始，形式为 $ + 名称或编号 。32个32位单精度浮点数寄存器，可配对成16个16位双精度浮点数寄存器。两个乘商寄存器Hi和Lo，除法时余数放在Hi中，商在Lo中。PC指出下条指令所在地址。

| 名称            | 编号          | 功能              |
| ------------- | ----------- | --------------- |
| zero          | 0           | 恒为0             |
| at            | 1           | 为汇编程序保留         |
| $v_0\sim v_1$ | $2\sim3$    | 过程调用返回值         |
| $a_0\sim a_3$ | $4\sim 7$   | 过程调用参数          |
| $t_0\sim t_7$ | $8\sim15$   | 临时变量            |
| $s_0\sim s_7$ | $16\sim 23$ | 临时变量，被调用过程需保存   |
| $t_8\sim t_9$ | $24\sim25$  | 临时变量,在被调用过程无需保存 |
| $k_0\sim k_1$ | $26\sim 27$ | 为OS保留           |
| gp            | 28          | 全局指针            |
| sp            | 29          | 栈指针             |
| fp            | 30          | 帧指针             |
| ra            | 31          | 过程调用返回地址        |
<font face='Consolas'>MIPS</font>的存储器按字节编址，大端方式存储数据，数据要求按字边界对齐。对于立即操作数，指令中给出16位，使用时需要进行*符号拓展*或*0拓展*。

R型指令格式

| OP(31-26) | rs(25-21) | rt(20-16) | rd(15-11) | shamt(10-6) | func(5-0) |
| --------- | --------- | --------- | --------- | ----------- | --------- |
R型指令寻址方式：**寄存器寻址**

I型指令格式

| OP(31-26) | rs(25-21) | rt(20-16) | Imm16(15-0) |
| --------- | --------- | --------- | ----------- |
I型指令寻址方式：**寄存器寻址**、**立即数寻址**、**相对寻址**、**基址或变址寻址**
分支指令目标地址计算方式：PC + 符号拓展Imm16

J型指令格式

| OP(31-26) | address(25-0) |
| --------- | ------------- |
J型指令寻址方式:{PC[31:28],address[25:0],00}，即变通的直接寻址

**为什么J型指令最后要填两个0？**
因为一条指令占四个存储单元，所以指令地址总是4的倍数
R型指令：add sub and or nor sll srl slt jr
I型指令：andi ori beq bne lw sw 
J型指令：j jal 






